{
    "problem": "theory TreeReverseInj\n  imports Main\nbegin\n\ndatatype tree = Leaf | Node tree int tree\n\nfun tree_reverse :: \"tree \\<Rightarrow> tree\" where\n  \"tree_reverse Leaf = Leaf\"\n| \"tree_reverse (Node l v r) = Node (tree_reverse r) v (tree_reverse l)\"\n\nlemma tree_reverse_inj: \"tree_reverse t1 = tree_reverse t2 \\<Longrightarrow> t1 = t2\"\n(* Fill Your Proof Here *)\nend",
    "proof": "proof (induction t1 arbitrary: t2)\n  case Leaf\n  then have \"tree_reverse t2 = Leaf\" by simp\n  thus ?case\n  proof (cases t2)\n    case Leaf\n    then show ?thesis by simp\n  next\n    case (Node l v r)\n    then have \"tree_reverse t2 = Node (tree_reverse r) v (tree_reverse l)\" by simp\n    with `tree_reverse t2 = Leaf` show ?thesis by simp\n  qed\nnext\n  case (Node l1 v1 r1)\n  then obtain t2_l t2_v t2_r where t2_eq: \"t2 = Node t2_l t2_v t2_r \\<or> t2 = Leaf\"\n    by (cases t2) auto\n  then show ?case\n  proof\n    assume \"t2 = Leaf\"\n    with Node.prems have \"tree_reverse t2 = Leaf\" by simp\n    then have \"Node (tree_reverse r1) v1 (tree_reverse l1) = Leaf\" using Node.prems by simp\n    thus ?thesis by simp\n  next\n    assume t2_is_node: \"t2 = Node t2_l t2_v t2_r\"\n    with Node.prems have eq_nodes: \"Node (tree_reverse r1) v1 (tree_reverse l1) = Node (tree_reverse t2_r) t2_v (tree_reverse t2_l)\" by simp\n    then have eq_vals: \"v1 = t2_v\" and eq_left: \"tree_reverse l1 = tree_reverse t2_l\" and eq_right: \"tree_reverse r1 = tree_reverse t2_r\" by auto\n    from Node.IH[OF eq_right] have \"r1 = t2_r\" by blast\n    from Node.IH[OF eq_left] have \"l1 = t2_l\" by blast\n    with `v1 = t2_v` `r1 = t2_r` t2_is_node show ?thesis by simp\n  qed\nqed\n\nend",
    "proposition": "tree_reverse_inj",
    "id": 38
}